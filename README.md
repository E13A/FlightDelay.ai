# Comprehensive Technical Report: Cybersecurity Project (SIEM, WAF, SOAR)

## 1. Executive Summary

In the contemporary landscape of digital threats, securing web applications requires more than just reactive measures; it demands a proactive, layered defense ecosystem. This project implements a sophisticated cybersecurity platform integrating three pivotal components: a **Web Application Firewall (WAF)** for real-time traffic inspection, a **Security Information and Event Management (SIEM)** system for centralized log analysis, and a **Security Orchestration, Automation, and Response (SOAR)** module for autonomous threat mitigation.

The developed solution functions as a cohesive unit. The WAF leverages Linux kernel `NetfilterQueue` to intercept and analyze HTTP traffic at the network layer, applying deep packet inspection (DPI) to identify attacks such as SQL Injection (SQLi) and Cross-Site Scripting (XSS). Upon detection, the SOAR engine executes an immediate response by temporarily banning the malicious IP address and notifying security administrators via Telegram. Simultaneously, the SIEM component ingests logs from both the WAF and the web server, visualizing security posture through a dynamic dashboard.

Testing results demonstrate the system’s efficacy: it successfully blocked 100% of injected SQL and XSS payloads and enforced rate limits with sub-second precision. By automating the detection-to-response pipeline, the platform reduces the window of exposure from minutes to milliseconds, proving its viability as a robust educational prototype for modern protection strategies.

---

## 2. Introduction

### 2.1 Background
Web applications are the primary interface for digital business but are also the most frequent targets of cyberattacks. The Open Web Application Security Project (OWASP) Top 10 consistently highlights vulnerabilities like Injection and Broken Access Control as critical risks. Traditional firewalls (layer 3/4) are insufficient against these application-layer (layer 7) attacks, necessitating specialized tools like WAFs. Furthermore, the sheer volume of logs generated by modern infrastructure overwhelms human analysts, driving the need for SIEM systems to correlate data and SOAR tools to automate responses.

### 2.2 Project Scope or Objectives
The primary objective of this project was to design and implement a "Purple Team" environment—a defensive setup that can be actively tested against offensive techniques.
Key goals included:
*   **Real-time Traffic Analysis**: Creating a custom WAF capable of inspecting specific patterns in HTTP headers and bodies.
*   **Centralized Visibility**: Building a SIEM dashboard to provide a "single pane of glass" view of the security state.
*   **Closed-Loop Automation**: Implementing SOAR logic where detection triggers an immediate, unassisted response (IP banning).
*   **Alerting**: Ensuring stakeholders are notified instantly of high-severity incidents.

---

## 3. System Design and Architecture

### 3.1 High-Level Architecture
The system adopts a modular, service-oriented architecture where components are loosely coupled but highly interactive.

*   **The Interceptor (WAF)**: Sits inline with network traffic. It acts as a gateway, deciding which packets pass to the application and which are dropped. It is the "muscle" of the operation.
*   **The Brain (SIEM)**: Acts as the data warehouse. It receives telemetry from the WAF (alerts) and the web server (access logs), normalizing this data for analysis.
*   **The Responder (SOAR)**: Acts as the reflex system. It maintains the "state" of the network (e.g., list of banned IPs) and executes actions based on WAF triggers.

### 3.2 Diagrammatic Representation
The following diagram illustrates the data flow from an external attacker through the defense layers.

```mermaid
graph TD
    Attacker[External Attacker] -->|Malicious HTTP Request| NFQueue[Netfilter Queue (Kernel)]
    NFQueue -->|Packet Copy| WAF[WAF Engine (waf.py)]
    
    subgraph "Detection & Mitigation Layer"
        WAF -->|Analyze Payload| Inspector{Deep Packet Inspection}
        Inspector -->|Attack Detected?| Decision
        Decision -- Yes --> Drop[Drop Packet]
        Decision -- Yes --> SOAR_Trigger(Trigger SOAR)
        Decision -- No --> Forward[Accept Packet]
    end
    
    subgraph "SOAR Logic"
        SOAR_Trigger --> BanList[(In-Memory Ban List)]
        SOAR_Trigger --> Telegram[Telegram Bot API]
    end
    
    subgraph "SIEM Ecosystem"
        Forward --> WebServer[Apache Web Server]
        WebServer -->|Writes| AccessLog[access.log]
        AccessLog -->|Tails| LogIngester[log_ingest.py]
        LogIngester -->|POST /ingest| API[SIEM API (FastAPI)]
        WAF -->|POST /ingest (Alerts)| API
        API -->|Store| DB[(SQLite Database)]
        Dashboard[Dash Frontend] -->|Polls| API
    end
```

### 3.3 Technology Stack Justification
*   **Language**: Python 3.9+ was chosen for its rich ecosystem of security libraries (`scapy`) and rapid prototyping capabilities.
*   **Packet Manipulation**: `Scapy` and `NetfilterQueue` were selected to allow raw manipulation of IP/TCP packets, providing granular control over traffic that standard proxy-based WAFs might abstract away.
*   **Backend Framework**: `FastAPI` provides high-performance, asynchronous endpoints critical for handling bursts of log ingestion traffic.
*   **Data Storage**: `SQLite` was used for its simplicity and zero-configuration deployment, suitable for an educational MVP, though replacable with PostgreSQL for production.
*   **Visualization**: `Dash` (by Plotly) offers strictly analytical UI components, making it superior to general-purpose web frameworks for rendering time-series security data.

---

## 4. Component Implementation: Web Application Firewall (WAF)

The WAF is the most complex component, operating at the intersection of network engineering and application security. It does not merely read logs; it actively interferes with network traffic.

### 4.1 Packet Interception with NetfilterQueue
The WAF relies on Linux's `iptables` to divert traffic to a user-space queue.
*   **Command**: `iptables -I INPUT -p tcp --dport 80 -j NFQUEUE --queue-num 1`
*   **Mechanism**: This rule instructs the kernel to look at any TCP packet destined for port 80. Instead of delivering it to the destination application immediately, the kernel places the packet in Queue #1.
*   **Python Integration**: The `waf.py` script binds to this queue. For every packet, it extracts the payload and converts it into a `scapy` IP object. This allows the script to read (and potentially modify) headers and payloads before issuing a verdict: `packet.accept()` or `packet.drop()`.

### 4.2 Deep Packet Inspection (DPI) Logic
Once a packet is captured, the WAF reconstructs the TCP payload to identify HTTP messages.
1.  **Extraction**: The script strips headers to find the HTTP body.
2.  **Decoding**: It handles URL-encoding (`%20`, `%27`) to prevent evasion techniques where attackers encode malicious characters.
3.  **Pattern Matching**: The core detection engine uses Python's `re` module with pre-compiled regex signatures.

#### Attack Signatures
*   **SQL Injection (SQLi)**:
    *   *Logic*: Looks for SQL keywords (`UNION`, `SELECT`, `FROM`) or tautologies (`OR 1=1`).
    *   *Regex*: `(?i)\bunion\b.*\bselect\b`, `(?i)\bor\s+1\s*=\s*1\b`
    *   *Context*: Matches against URI paths (GET) and request bodies (POST).
*   **Cross-Site Scripting (XSS)**:
    *   *Logic*: Scans for HTML tags capable of execution.
    *   *Regex*: `(?i)<script\b`, `(?i)on\w+\s*=` (catching event handlers like `onload`), `javascript:`
*   **Command Injection**:
    *   *Logic*: Identifies shell delimiters followed by system commands.
    *   *Regex*: `[;&|`]\s*(?:ls|cat|whoami|id)`
    
### 4.3 Rate Limiting Algorithm
To mitigate DoS attacks, the WAF implements a **Fixed Window Counter** algorithm.
*   **Data Structure**: A dictionary mapping IP addresses to lists of request timestamps: `Dict[IP, List[Timestamp]]`.
*   **Flow**:
    1.  On each packet, prune timestamps older than the window (e.g., 60 seconds).
    2.  Check the count of remaining timestamps.
    3.  If count > Threshold (100), trigger Rate Limit logic (Drop packet & Send 429 Response).
    4.  Else, append current timestamp and allow.
*   **Response**: Unlike silent drops, the WAF actively constructs a new TCP packet with an HTTP `429 Too Many Requests` status and injects it back to the client, ensuring the user knows they are throttled.

---

## 5. Component Implementation: SIEM

The SIEM moves beyond detection to analysis, providing the historical context needed for forensics.

### 5.1 Log Ingestion Pipeline
The ingestion layer addresses the challenge of heterogeneous data sources.
*   **Log Ingest Script**: A standalone daemon (`log_ingest.py`) monitors the Apache `access.log`. It parses the Common Log Format (CLF) into a structured JSON object comprising `source`, `timestamp`, `method`, `url`, and `status_code`.
*   **Transformation**: HTTP status codes are mapped to severity levels:
    *   `5xx` -> **ERROR**
    *   `4xx` -> **WARNING**
    *   `2xx/3xx` -> **INFO**
    *   **Resilience**: The ingestor implements a "tail-f" mechanism using file seeking to read logs in real-time without locking the file. It also features a retry loop for API POST requests, ensuring data isn't lost if the SIEM API is temporarily down.

### 5.2 Database Schema
Persistence is handled by SQLAlchemy. The schema is normalized for query efficiency.
*   **Table**: `events`
    *   `id`: Primary Key
    *   `timestamp`: DateTime (Indexed for time-series querying)
    *   `source`: String (IP Address)
    *   `event_type`: String (e.g., "SQLi", "Login", "/home")
    *   `level`: String (Severity)
    *   `message`: Text (Raw log or detailed alert info)

### 5.3 Dashboard & Visualization
The Dashboard is built on the Plotly Dash framework, which allows for reactive, callback-based UI updates.
*   **Real-time Callback**: An interval component fires every 5 seconds, triggering a fetch of the last 100 events from the API.
*   **Timezone Intelligence**: The system handles the complexity of mixing sources. WAF alerts (generated internally in UTC) and Apache logs (system local time) are normalized efficiently using Pandas `dt.tz_convert` to ensure the timeline graph is accurate.
*   **Visual Components**:
    *   *Line Chart*: Event volume over time (5-minute buckets).
    *   *Bar Chart*: Attack types breakdown (demonstrating the "threat landscape").
    *   *Table*: Detailed event log for drill-down analysis.
    *   *Status Panel*: Live view of currently banned and rate-limited IPs, pulled from the WAF's internal state API.

---

## 6. Component Implementation: SOAR

The SOAR module represents the "Active" defense capability.

### 6.1 State Management & Banning Logic
The SOAR logic is embedded within the WAF capabilities to ensure minimal latency (microseconds).
*   **Banning**: When a "Critical" signature (SQLi/XSS) is matched, the implementation does not just drop the current packet. It adds the source IP to a `banned_ips` dictionary with an expiration timestamp (`current_time + 180s`).
*   **Enforcement**: Packet processing checks this ban list *before* running expensive regex matches. If an IP is banned, the packet is eagerly dropped. This "fail-fast" mechanism protects the WAF CPU from being overwhelmed by a persistent attacker.

### 6.2 External Communication (Telegram)
Human awareness is maintained via API integration.
*   **Trigger**: The `telegram.send_alert()` function is called asynchronously upon detection.
*   **Deduplication**: To prevent "alert fatigue" (spamming the admin with 1000 messages for a single brute-force attack), the system implements a dampening logic. It tracks the `last_alert_time` for each `(IP, AttackType)` pair and silences notifications if a previous one was sent within the last 60 seconds.
*   **Payload**: The alert is rich-text formatted (HTML), providing the analyst with:
    *   Attack Type (e.g., "SQL Injection")
    *   Source IP
    *   The specific Payload snippet that triggered the rule (e.g., `UNION SELECT *`).

---

## 7. Testing & Evaluation

### 7.1 Methodology
Testing was conducted using a "Black Box" approach. The system played the role of the defender, while a separate Kali Linux machine acted as the attacker. Tools used included `curl`, `ab` (Apache Bench), and custom Python attack scripts.

### 7.2 Functional Test Cases & Results

| Test Case ID | Description | Payload/Action | Expected Outcome | Actual Result |
| :--- | :--- | :--- | :--- | :--- |
| **TC-001** | **SQL Injection Prevention** | GET `/?q=' OR 1=1 --` | WAF Blocks (403), Alert Sent | **Pass**. Connection reset. Telegram alert received. |
| **TC-002** | **XSS Prevention** | POST body `<script>alert(1)</script>` | WAF Blocks (403), Alert Sent | **Pass**. Request dropped. Dashboard showed "XSS". |
| **TC-003** | **Command Injection** | GET `/?cmd=; cat /etc/passwd` | WAF Blocks (403), IP Banned | **Pass**. IP banned for 180s. |
| **TC-004** | **Rate Limit Enforcement** | 150 requests in 10 sec via `ab` | Requests > 100 get 429 code | **Pass**. 100 success, 50 failures (429). |
| **TC-005** | **False Positive Check** | GET `/search?q=union_of_sets` | Traffic Allowed (200 OK) | **Pass**. Keyword "union" alone did not trigger. |

### 7.3 Performance Evaluation
*   **Latency**: The overhead introduced by the WAF was measured.
    *   *Baseline (No WAF)*: ~2ms RTT.
    *   *With WAF (Clean traffic)*: ~5ms RTT.
    *   *Conclusion*: The 3ms overhead is negligible for standard web applications but highlights the efficiency of the Python-based NFQueue implementation.
*   **Throughput**: The system handled ~200 requests/second before showing signs of CPU saturation (due to Python's GIL), which is acceptable for the project scope.

---

## 8. Security Considerations

### 8.1 Strengths
*   **Behavioral Enforcement**: Unlike log-based tools (Fail2Ban) that ban *after* the request is processed, this WAF blocks the request *before* it hits the server, preventing the exploit from ever executing.
*   **Self-Protection**: The WAF protects the SIEM backend by filtering noise.

### 8.2 Limitations
*   **Encrypted Traffic**: The current implementation inspects standard HTTP. HTTPS traffic would pass through encrypted unless the WAF is set up as a trusted Man-in-the-Middle proxy (SSL Termination).
*   **Bypass Potential**: Sophisticated evasions (e.g., splitting payloads across packets) might bypass the regex engine.
*   **State Persistence**: The ban list is in-memory. If the WAF service restarts, banned IPs are cleared.

---

## 9. Future Enhancements

To evolve this MVP into a production-grade system, the following roadmap is proposed:
1.  **Machine Learning Integration**: Replace static regex with an Anomaly Detection model (e.g., Isolation Forest) trained on "normal" traffic patterns to detect zero-day attacks.
2.  **Distributed Database**: Migrate from SQLite to ElasticSearch or PostgreSQL to handle millions of logs without performance degradation.
3.  **Authentication Layer**: Secure the internal SIEM APIs using JWT signatures to prevent unauthorized log injection.
4.  **User Behavior Analytics (UBA)**: Track session tokens to identify account takeover attempts, not just IP-based attacks.

---

## 10. Conclusion

This project successfully demonstrates the power of a converged security architecture. By integrating the visibility of a **SIEM**, the protective capabilities of a **WAF**, and the speed of **SOAR**, the system provides a robust defense against common web vulnerabilities. The implementation highlights the critical balance between security enforcement and system availability, offering a practical template for understanding modern cybersecurity defense mechanisms.
